<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemelo Digital - Planificación de Escoliosis (Doble Vista)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/"
      }
    }
  </script>
  <style>
    #digital-twin-canvas { width: 100%; height: 100%; min-height: 520px; border-radius: 0.5rem; background:#111827; display: none; }
    input[type="file"] { display:none; }
    .custom-file-upload { display:inline-block; padding:0.75rem 1.25rem; cursor:pointer; background:#4f46e5; color:#fff; border-radius:0.5rem; font-weight:600; transition:background .3s; }
    .custom-file-upload:hover { background:#4338ca; }
    
    /* Clase genérica para botones activos */
    .tool-active { box-shadow:0 0 0 3px #10b981; background:#059669 !important; }
    /* NUEVO: Clase específica para botones de trazador */
    .plotter-button.tool-active { background: #4f46e5; box-shadow: 0 0 0 3px #a5b4fc; }

    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    
    #image-plotter-svg { cursor: crosshair; }
    #image-plotter-svg circle { transition: all 0.1s ease; }
    #image-plotter-svg circle:hover { r: 8px; fill-opacity: 0.8; }

    /* Estilo para dropzone */
    /* Eliminadas las reglas para .dropzone y .dropzone.dragover */
  </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans antialiased">
  <!-- Header --><header class="bg-gray-800 shadow-lg">
    <div class="container mx-auto px-6 py-4 flex items-center justify-between">
      <div>
        <h1 class="text-2xl font-bold text-white">Plataforma de Gemelo Digital</h1>
        <h2 class="text-lg text-indigo-300">Planificación prequirúrgica de escoliosis (AP + LAT)</h2>
      </div>
      <div class="hidden lg:flex gap-2 text-sm text-gray-300">
        <div class="px-2 py-1 rounded bg-gray-700"><span class="kbd">C</span> Cobb</div>
        <div class="px-2 py-1 rounded bg-gray-700"><span class="kbd">S</span> Tornillos (Clic)</div>
        <div class="px-2 py-1 rounded bg-gray-700"><span class="kbd">R</span> Reset</div>
        <div class="px-2 py-1 rounded bg-gray-700"><span class="kbd">E</span> Exportar</div>
      </div>
    </div>
  </header>

  <!-- Layout principal (cols-4) --><main class="container mx-auto p-6 grid grid-cols-1 lg:grid-cols-4 gap-6">
    <!-- Sidebar --><aside class="lg:col-span-1 bg-gray-800 p-6 rounded-lg shadow-xl flex flex-col gap-6">
      
      <!-- MODIFICADO: Sección de Carga de Imágenes (Doble) --><section>
        <h3 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">1. Cargar Imágenes</h3>
        
        <!-- Carga AP --><div class="mb-4">
          <label for="file-upload-ap" class="custom-file-upload w-full text-center">Img. AP (Frente)…</label>
          <input id="file-upload-ap" type="file" accept="image/jpeg,image/png" />
          <p id="file-name-ap" class="text-gray-400 text-sm mt-3">Ningún archivo AP seleccionado.</p>
          <!-- <div id="dropzone-ap" class="dropzone"> ... </div> --><!-- Elemento eliminado --></div>

        <!-- Carga Lateral --><div>
          <label for="file-upload-lat" class="custom-file-upload w-full text-center bg-indigo-700 hover:bg-indigo-800">Img. Lateral (Lado)…</label>
          <input id="file-upload-lat" type="file" accept="image/jpeg,image/png" />
          <p id="file-name-lat" class="text-gray-400 text-sm mt-3">Ningún archivo LAT seleccionado.</p>
          <!-- <div id="dropzone-lat" class="dropzone"> ... </div> --><!-- Elemento eliminado --></div>
      </section>

      <!-- Sección de Trazado de Curva (Modificada) --><section id="plotting-section" class="hidden">
        <h3 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">2. Trazar Curvas 2D</h3>
        
        <!-- Botones de modo de trazado --><div class="grid grid-cols-2 gap-2 mb-3">
          <button id="btn-trace-ap" class="plotter-button w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-lg transition">Trazar AP (Coronal)</button>
          <button id="btn-trace-lat" class="plotter-button w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-lg transition disabled:opacity-50" disabled>Trazar LAT (Sagital)</button>
        </div>

        <p class="text-sm text-gray-300 mb-3">Haga clic en la imagen (derecha) para marcar el centro de cada vértebra, de arriba hacia abajo.</p>
        
        <!-- Conteo de puntos --><div id="plot-point-count" class="text-lg font-medium text-yellow-300 mb-4">
          <div>Puntos AP (Verdes): 0</div>
          <div>Puntos LAT (Azules): 0</div>
        </div>

        <div class="flex flex-col gap-3">
          <button id="generate-3d-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:opacity-50" disabled>Generar Modelo 3D</button>
          <button id="clear-plot-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-3 rounded-lg transition">Limpiar Puntos (Vista Activa)</button>
        </div>
      </section>

      <section>
        <!-- Paso 3 --><h3 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">3. Herramientas de planificación</h3>
        <div id="tools-panel" class="flex flex-col gap-3 opacity-50 cursor-not-allowed">
          <!-- (Botones sin cambios) --><button id="tool-cobb" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg transition disabled:opacity-50" disabled>Medir ángulo de Cobb</button>
          <button id="tool-screws" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg transition disabled:opacity-50" disabled>Colocar Tornillos (Interactivo)</button>
          <button id="tool-rod" class="tool-button w-full text-left bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg transition disabled:opacity-50" disabled>Simular corrección con barra</button>
        </div>

        <!-- (Paneles de herramientas sin cambios) --><div id="screw-instruction-panel" class="hidden mt-3 bg-gray-700/60 text-gray-200 p-3 rounded-md text-sm">
          <b>Modo Tornillos Activo:</b> Haga clic en una vértebra (ej. T7, L2) para colocar/quitar un par de tornillos pediculares.
        </div>
        <div id="cobb-results-panel" class="hidden mt-6 p-4 bg-gray-700 rounded-lg">
          <h4 class="text-lg font-bold text-green-300 mb-2">Análisis de ángulo de Cobb</h4>
          <p id="cobb-instruction" class="text-sm text-gray-300 mb-2">Seleccione 3 puntos en la placa superior de la vértebra superior.</p>
          <div id="cobb-selected-points" class="text-sm text-yellow-300">Puntos placa superior: 0/3<br/>Puntos placa inferior: 0/3</div>
          <p id="cobb-result" class="text-3xl font-extrabold mt-4 text-green-400">0.0°</p>
          <div id="cobb-actions" class="mt-4 flex gap-2 hidden">
            <button id="save-cobb" class="w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg transition">Guardar medición</button>
            <button id="clear-cobb" class="w-1/2 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg transition">Limpiar selección</button>
          </div>
        </div>
        <div id="cobb-history-panel" class="mt-6 p-4 bg-gray-800 rounded-lg border border-gray-700 hidden">
           <h4 class="text-lg font-bold text-indigo-300 mb-3 border-b border-gray-700 pb-2">Mediciones guardadas</h4>
          <ul id="cobb-measurements-list" class="space-y-2">
            <li class="text-gray-400 italic">No hay mediciones guardadas.</li>
          </ul>
        </div>

        <button id="tool-export" class="w-full text-left bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg transition mt-4 disabled:opacity-50" disabled>Exportar plan quirúrgico</button>
      </section>
    </aside>

    <!-- Canvas (col-span-3) --><section class="lg:col-span-3 bg-gray-800 p-6 rounded-lg shadow-xl">
      <h3 id="main-viewer-title" class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">Visor Principal</h3>
      <div id="canvas-container" class="relative w-full h-[520px] lg:h-[620px] bg-gray-900 rounded-lg overflow-hidden">
        <div id="loading-message" class="absolute inset-0 flex flex-col items-center justify-center z-10">
          <svg id="initial-icon" xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M5 12s2.545-5 7-5c4.454 0 7 5 7 5s-2.546 5-7 5c-4.455 0-7-5-7-5z"/><path d="M12 13a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/><path d="M2 12s2.946-8 10-8 10 8 10 8-2.946 8-10 8S2 12 2 12z"/></svg>
          <p id="loading-text" class="text-gray-500 text-lg mt-4">Cargue una imagen AP y LAT para iniciar.</p>
        </div>
        
        <!-- Contenedor para el trazado 2D --><div id="image-plotter-container" class="absolute inset-0 z-20 hidden bg-gray-900">
          <img id="image-plotter-preview" src="#" alt="Trazador 2D" class="w-full h-full object-contain" />
          <svg id="image-plotter-svg" class="absolute inset-0 w-full h-full"></svg>
        </div>

        <canvas id="digital-twin-canvas"></canvas> <!-- display: none --><!-- Toast --><div id="toast" class="hidden absolute bottom-4 left-1/2 -translate-x-1/2 bg-black/70 text-white text-sm px-4 py-2 rounded-full"></div>
      </div>
    </section>
  </main>

  <script type="module">
    // Imports
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    // ... (loadSubdivisionModifier sin cambios) ...
    let SubdivisionModifierSafe = null;
    async function loadSubdivisionModifier(){
      if(SubdivisionModifierSafe) return SubdivisionModifierSafe;
      try{
        const mod = await import('three/addons/modifiers/SubdivisionModifier.js');
        SubdivisionModifierSafe = mod.SubdivisionModifier || null;
      }catch(err){
        console.warn('SubdivisionModifier no disponible, continuando sin subdivisión:', err);
        SubdivisionModifierSafe = null;
      }
      return SubdivisionModifierSafe;
    }

    // ---------- Estado global ----------
    let scene, camera, renderer, controls, spineGroup;
    const canvas = document.getElementById('digital-twin-canvas');
    const canvasContainer = document.getElementById('canvas-container');
    const loadingMessage = document.getElementById('loading-message');
    const loadingText = document.getElementById('loading-text');
    const initialIcon = document.getElementById('initial-icon');
    const toolsPanel = document.getElementById('tools-panel');
    const toast = document.getElementById('toast');
    const mainViewerTitle = document.getElementById('main-viewer-title');

    // --- NUEVO: Estado de Carga y Trazado 2D (Doble) ---
    let imageDataAP = null;
    let imageDataLAT = null;
    let patientSpinePoints2D_AP = []; // Almacena {x, y} en coordenadas de SVG (Coronal)
    let patientSpinePoints2D_LAT = []; // Almacena {x, y} en coordenadas de SVG (Sagital)
    let currentTracingMode = 'AP'; // 'AP' | 'LAT'

    // DOM Refs Trazador
    const fileUploadAP = document.getElementById('file-upload-ap');
    const fileUploadLAT = document.getElementById('file-upload-lat');
    // const dropzoneAP = document.getElementById('dropzone-ap'); // Eliminado
    // const dropzoneLAT = document.getElementById('dropzone-lat'); // Eliminado
    const fileNameElAP = document.getElementById('file-name-ap');
    const fileNameElLAT = document.getElementById('file-name-lat');
    
    const plottingSection = document.getElementById('plotting-section');
    const btnTraceAP = document.getElementById('btn-trace-ap');
    const btnTraceLAT = document.getElementById('btn-trace-lat');
    const plotPointCount = document.getElementById('plot-point-count');
    const generate3dBtn = document.getElementById('generate-3d-btn');
    const clearPlotBtn = document.getElementById('clear-plot-btn');
    
    const imagePlotterContainer = document.getElementById('image-plotter-container');
    const imagePlotterPreview = document.getElementById('image-plotter-preview');
    const imagePlotterSvg = document.getElementById('image-plotter-svg');
    // --- FIN DE NUEVO ESTADO ---

    let toolMode = null; // null | 'cobb' | 'screws' | 'rod'

    // Estado de Herramientas (sin cambios)
    let cobbClickPoints = []; 
    let currentCobbAngle = 0.0;
    const COBB_POINTS_GROUP = new THREE.Group();
    let savedCobbMeasurements = [];
    const SCREWS_GROUP = new THREE.Group();
    const screwMaterial = new THREE.MeshStandardMaterial({ color: 0xFFA500, metalness: 0.8, roughness: 0.2 });
    const screwGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3.5, 8);
    screwGeometry.translate(0, 1.75, 0);
    const RODS_GROUP = new THREE.Group();

    // DOM refs Herramientas (sin cambios)
    const cobbButton = document.getElementById('tool-cobb');
    const screwsButton = document.getElementById('tool-screws');
    const rodButton = document.getElementById('tool-rod');
    const cobbResultsPanel = document.getElementById('cobb-results-panel');
    
    /* INICIO DE LA CORRECCIÓN: Definiciones de variables de Cobb */
    const cobbInstruction = document.getElementById('cobb-instruction');
    const cobbSelectedPoints = document.getElementById('cobb-selected-points');
    const cobbResult = document.getElementById('cobb-result');
    const cobbActions = document.getElementById('cobb-actions');
    const saveCobbButton = document.getElementById('save-cobb');
    const clearCobbButton = document.getElementById('clear-cobb'); // <-- Esta era la variable que faltaba
    const cobbHistoryPanel = document.getElementById('cobb-history-panel');
    const cobbMeasurementsList = document.getElementById('cobb-measurements-list');
    /* FIN DE LA CORRECCIÓN */

    const screwInstructionPanel = document.getElementById('screw-instruction-panel');
    const exportButton = document.getElementById('tool-export');

    // Raycaster (sin cambios)
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ---------- Utilidades UI (sin cambios) ----------
    function showToast(msg, timeout = 1800) {
      toast.textContent = msg;
      toast.classList.remove('hidden');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.add('hidden'), timeout);
    }

    function enableTools() {
      toolsPanel.classList.remove('opacity-50', 'cursor-not-allowed');
      toolsPanel.querySelectorAll('.tool-button').forEach(btn => btn.disabled = false);
      exportButton.disabled = false;
    }

    // ---------- NUEVO: Carga de imagen (Doble) ----------
    
    // Listeners para AP
    fileUploadAP.addEventListener('change', (e) => handleFile(e.target.files?.[0], 'AP'));
    // setupDropzone(dropzoneAP, 'AP'); // Eliminado

    // Listeners para LAT
    fileUploadLAT.addEventListener('change', (e) => handleFile(e.target.files?.[0], 'LAT'));
    // setupDropzone(dropzoneLAT, 'LAT'); // Eliminado

    /* La función setupDropzone completa fue eliminada */

    function handleFile(file, mode) {
      if(!file) return;
      if(!/^image\/(jpeg|png)$/.test(file.type)) { showToast('Formato no soportado. Use JPG o PNG.'); return; }
      
      const fileNameEl = (mode === 'AP') ? fileNameElAP : fileNameElLAT;
      fileNameEl.textContent = file.name;

      const reader = new FileReader();
      reader.onload = (ev)=>{
        if (mode === 'AP') {
          imageDataAP = ev.target?.result;
        } else {
          imageDataLAT = ev.target?.result;
          btnTraceLAT.disabled = false; // Habilitar botón de trazado LAT
        }

        // Mostrar sección de trazado si no estaba visible
        plottingSection.classList.remove('hidden');
        
        // Si es la primera imagen cargada (o AP), establecerla como activa
        if (mode === 'AP' || !imageDataAP) {
          setTracingMode('AP');
        }

        // Ocultar mensaje inicial "Cargue imagen"
        loadingMessage.classList.add('hidden'); 
        
        // Limpiar estado 3D anterior si existe
        resetTo2DPlotting();
      };
      reader.readAsDataURL(file);
    }
    
    /**
     * Resetea el estado de vuelta al trazador 2D (cuando se carga una nueva imagen)
     */
    function resetTo2DPlotting() {
        // Limpiar estado anterior 3D
        resetToolMode();
        canvas.style.display = 'none';
        toolsPanel.classList.add('opacity-50', 'cursor-not-allowed');
        toolsPanel.querySelectorAll('.tool-button').forEach(btn => btn.disabled = true);
        exportButton.disabled = true;

        // Mostrar el trazador (si el modo actual tiene una imagen)
        const currentImage = (currentTracingMode === 'AP') ? imageDataAP : imageDataLAT;
        if (currentImage) {
          imagePlotterContainer.classList.remove('hidden');
        }
    }

    // ---------- NUEVO: Funciones Trazador 2D (Modo Dual) ----------

    // Listeners para botones de modo
    btnTraceAP.addEventListener('click', () => setTracingMode('AP'));
    btnTraceLAT.addEventListener('click', () => setTracingMode('LAT'));
    
    /**
     * Establece el modo de trazado actual (AP o LAT).
     */
    function setTracingMode(mode) {
      if (mode === 'AP' && !imageDataAP) {
        showToast('Cargue una imagen AP primero.');
        return;
      }
      if (mode === 'LAT' && !imageDataLAT) {
        showToast('Cargue una imagen LAT primero.');
        return;
      }
      
      currentTracingMode = mode;
      
      // Actualizar botones
      btnTraceAP.classList.toggle('tool-active', mode === 'AP');
      btnTraceLAT.classList.toggle('tool-active', mode === 'LAT');
      
      // Actualizar imagen de preview
      imagePlotterPreview.src = (mode === 'AP') ? imageDataAP : imageDataLAT;
      imagePlotterContainer.classList.remove('hidden');
      
      // Actualizar título
      mainViewerTitle.textContent = `2. Trazar Curva 2D (${mode})`;
      
      // Redibujar SVG para el modo actual
      updatePlotterSVG();
    }
    
    /**
     * Maneja el clic en el SVG del trazador 2D.
     */
    function onPlotterClick(event) {
      const rect = imagePlotterSvg.getBoundingClientRect();
      const img = imagePlotterPreview;
      const svg = imagePlotterSvg;

      // Calcular escala y offset (lógica sin cambios)
      const realW = img.naturalWidth;
      const realH = img.naturalHeight;
      const aspectImg = realW / realH;
      const aspectSvg = svg.clientWidth / svg.clientHeight;
      let scale = 1.0, offsetX = 0, offsetY = 0;
      if (aspectImg > aspectSvg) {
        scale = svg.clientWidth / realW;
        offsetY = (svg.clientHeight - (realH * scale)) / 2;
      } else {
        scale = svg.clientHeight / realH;
        offsetX = (svg.clientWidth - (realW * scale)) / 2;
      }
      
      const svgX = event.clientX - rect.left;
      const svgY = event.clientY - rect.top;
      const imgX = (svgX - offsetX) / scale;
      const imgY = (svgY - offsetY) / scale;

      if (svgX < offsetX || svgY < offsetY || imgX > realW || imgY > realH) {
        showToast("Clic fuera de la imagen.");
        return;
      }

      // Añadir al array de puntos correcto
      const pointsArray = (currentTracingMode === 'AP') ? patientSpinePoints2D_AP : patientSpinePoints2D_LAT;
      pointsArray.push({ x: svgX, y: svgY });
      
      updatePlotterSVG();
      updatePlotCounts();
    }

    /**
     * Dibuja los puntos y líneas en el SVG del trazador (para el modo actual).
     */
    function updatePlotterSVG() {
      imagePlotterSvg.innerHTML = ''; // Limpiar SVG
      
      const pointsArray = (currentTracingMode === 'AP') ? patientSpinePoints2D_AP : patientSpinePoints2D_LAT;
      const pointColor = (currentTracingMode === 'AP') ? "#00ff00" : "#00aaff"; // Verde para AP, Azul para LAT
      const lineColor = (currentTracingMode === 'AP') ? "#a3e635" : "#60a5fa"; // Lima para AP, Azul claro para LAT

      if (pointsArray.length === 0) return;

      const ns = "http://www.w3.org/2000/svg";
      
      // Dibujar líneas
      if (pointsArray.length > 1) {
        const polyline = document.createElementNS(ns, "polyline");
        polyline.setAttribute("points", pointsArray.map(p => `${p.x},${p.y}`).join(" "));
        polyline.setAttribute("fill", "none");
        polyline.setAttribute("stroke", lineColor);
        polyline.setAttribute("stroke-width", "3");
        polyline.setAttribute("stroke-dasharray", "4 4");
        imagePlotterSvg.appendChild(polyline);
      }

      // Dibujar puntos
      pointsArray.forEach(p => {
        const circle = document.createElementNS(ns, "circle");
        circle.setAttribute("cx", p.x);
        circle.setAttribute("cy", p.y);
        circle.setAttribute("r", "5");
        circle.setAttribute("fill", pointColor);
        circle.setAttribute("stroke", "#ffffff");
        circle.setAttribute("stroke-width", "1.5");
        imagePlotterSvg.appendChild(circle);
      });
    }

    /**
     * Limpia los puntos del trazador 2D (para el modo actual).
     */
    function onClearPlot() {
      if (currentTracingMode === 'AP') {
        patientSpinePoints2D_AP = [];
      } else {
        patientSpinePoints2D_LAT = [];
      }
      updatePlotterSVG();
      updatePlotCounts();
    }
    
    /**
     * Actualiza el contador de puntos y habilita/deshabilita el botón 3D.
     */
    function updatePlotCounts() {
      plotPointCount.innerHTML = `
        <div>Puntos AP (Verdes): ${patientSpinePoints2D_AP.length}</div>
        <div>Puntos LAT (Azules): ${patientSpinePoints2D_LAT.length}</div>
      `;
      // Habilitar botón 3D solo si AMBAS curvas tienen puntos
      const canGenerate = patientSpinePoints2D_AP.length >= 2 && patientSpinePoints2D_LAT.length >= 2;
      generate3dBtn.disabled = !canGenerate;
    }

    /**
     * Inicia la generación 3D basada en los puntos 2D.
     */
    function onGenerate3D() {
      if (patientSpinePoints2D_AP.length < 2 || patientSpinePoints2D_LAT.length < 2) return;

      // Ocultar UI 2D
      imagePlotterContainer.classList.add('hidden');
      // plottingSection.classList.add('hidden'); // Opcional: mantener visible
      mainViewerTitle.textContent = "4. Gemelo Digital 3D (AP + LAT)";

      // Mostrar UI 3D
      canvas.style.display = 'block';
      
      // Iniciar simulación
      simulateDigitalTwinGeneration(patientSpinePoints2D_AP, patientSpinePoints2D_LAT);
    }
    
    // Añadir listeners de los botones
    imagePlotterSvg.addEventListener('click', onPlotterClick);
    generate3dBtn.addEventListener('click', onGenerate3D);
    clearPlotBtn.addEventListener('click', onClearPlot);

    // ---------- Simulación de procesamiento ----------
    // MODIFICADO: Acepta puntos AP y LAT
    function simulateDigitalTwinGeneration(points2D_AP = null, points2D_LAT = null){
      loadingText.textContent = 'Analizando curvas AP/LAT… construyendo modelo anatómico 3D…';
      initialIcon.classList.add('hidden');
      loadingMessage.classList.remove('hidden'); // Mostrar carga
      savedCobbMeasurements = [];
      updateCobbHistoryUI();
      resetToolMode();

      // Limpiar escena previa
      if(scene){
        scene.remove(spineGroup, COBB_POINTS_GROUP, SCREWS_GROUP, RODS_GROUP);
        disposeObject(spineGroup);
        COBB_POINTS_GROUP.clear();
        SCREWS_GROUP.clear();
        RODS_GROUP.clear();
      }

      setTimeout(()=>{
        loadingMessage.classList.add('hidden');
        if(!renderer) initThreeJS(points2D_AP, points2D_LAT); // Pasar puntos
        else {
          spineGroup = createScolioticSpine(points2D_AP, points2D_LAT); // Pasar puntos
          scene.add(spineGroup, COBB_POINTS_GROUP, SCREWS_GROUP, RODS_GROUP);
        }
        enableTools();
        canvas.addEventListener('mousedown', onCanvasMouseDown, false);
        showToast('Gemelo digital AP/LAT generado');
      }, 1200);
    }

    function disposeObject(obj){
      // ... (sin cambios) ...
      if(!obj) return;
      obj.traverse((child)=>{
        if(child.isMesh){
          child.geometry?.dispose?.();
          if(child.material){
            if(Array.isArray(child.material)) child.material.forEach(m=>m?.dispose?.());
            else if(child.material !== screwMaterial) child.material.dispose?.();
          }
        }
      });
    }

    // ---------- Inicializar Three.js ----------
    // MODIFICADO: Acepta puntos AP y LAT
    function initThreeJS(points2D_AP = null, points2D_LAT = null){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a202c);

      const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
      camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
      camera.position.set(20, 10, 30);
      camera.lookAt(0, 10, 0);

      renderer = new THREE.WebGLRenderer({ canvas, antialiias:true, powerPreference:'high-performance' });
      const DPR = Math.min(window.devicePixelRatio || 1, 2);
      renderer.setPixelRatio(DPR);
      renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);

      const pmrem = new THREE.PMREMGenerator(renderer);
      
      const ambientLight = new THREE.AmbientLight(0x606060);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); 
      dirLight.position.set(5,10,7.5); 
      scene.add(dirLight);

      new RGBELoader().load(
        'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr', 
        (tex)=>{
          const env = pmrem.fromEquirectangular(tex).texture; 
          scene.environment = env; 
          tex.dispose(); 
          pmrem.dispose();
        },
        undefined,
        (err) => { 
          console.warn("No se pudo cargar el entorno HDR. Usando iluminación de fallback.", err);
          ambientLight.intensity = 1.0; 
          dirLight.intensity = 1.5;
        }
      );
      
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0,10,0);
      controls.enableDamping = true; controls.dampingFactor = 0.05;

      spineGroup = createScolioticSpine(points2D_AP, points2D_LAT); // Pasar puntos
      scene.add(spineGroup, COBB_POINTS_GROUP, SCREWS_GROUP, RODS_GROUP);

      animate();
      window.addEventListener('resize', debounce(onWindowResize, 150));
    }

    function animate(){
      // ... (sin cambios) ...
      requestAnimationFrame(animate);
      controls?.update?.();
      renderer?.render?.(scene, camera);
    }

    function onWindowResize(){
      // ... (sin cambios) ...
      if(!camera || !renderer) return;
      const w = canvasContainer.clientWidth, h = canvasContainer.clientHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    }

    function debounce(fn, wait){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); } }

    // ---------- Construcción de columna (procedural mejorada) ----------
    
    /**
     * NUEVO: Refactorizado para procesar un array de puntos 2D en una función de curva 3D.
     */
    function processPointsToCurveMap(points2D, maxDeviation) {
      if (!points2D || points2D.length < 2) return null;
      try {
        let minY = Infinity, maxY = -Infinity, minX = Infinity, maxX = -Infinity;
        for (const p of points2D) {
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
        }
        const pixelHeight = maxY - minY;
        const pixelWidth = maxX - minX;
        const pixelCenterX = minX + pixelWidth / 2;
        
        const curvePoints = points2D.map(p => {
          const t_norm = (p.y - minY) / pixelHeight; 
          const x_norm = (pixelWidth > 0) ? (p.x - pixelCenterX) / (pixelWidth / 2) : 0;
          return new THREE.Vector3(x_norm, t_norm, 0); 
        });
        
        curvePoints.sort((a, b) => a.y - b.y);
        const interpCurve = new THREE.CatmullRomCurve3(curvePoints, false, 'catmullrom', 0.2);
        
        return (t_norm_0_to_1) => {
          const pointOnCurve = interpCurve.getPointAt(t_norm_0_to_1);
          return pointOnCurve.x * maxDeviation; // Devolver desviación 3D
        };
      } catch (err) {
        console.error("Error al procesar la curva 2D, usando fallback:", err);
        return null;
      }
    }
    
    // MODIFICADO: Acepta puntos 2D (AP y LAT)
    function createScolioticSpine(points2D_AP = null, points2D_LAT = null){
      const group = new THREE.Group();

      // Materiales (sin cambios)
      const boneColor = new THREE.Color('#e7d7c9');
      const vertebraMaterialBase = new THREE.MeshStandardMaterial({ color: boneColor, roughness: 0.6, metalness: 0.05 });
      const discMaterialBase = new THREE.MeshStandardMaterial({ color: 0x9aa0a6, roughness: 0.85, metalness: 0.02 });

      const NUM_CERVICAL = 7, NUM_THORACIC = 12, NUM_LUMBAR = 5, NUM_MOBILE = 24;
      const baseVertebraHeight = 1.0, baseDiscHeight = 0.25;
      let currentY = 0;

      // Utilidades (subd, rand, latheBodyProfile) (sin cambios)
      let subd = { modify: (g)=> g };
      if(!SubdivisionModifierSafe){
        loadSubdivisionModifier().then((Cls)=>{ if(Cls){ subd = new Cls(1); } });
      } else { subd = new SubdivisionModifierSafe(1); }
      const rand = (a,b)=> THREE.MathUtils.lerp(a,b, Math.random());
      function latheBodyProfile(scale, endplateConcavity=0.06){
        const r = 1.2 * scale; const h = 0.9 * scale; const pts = []; const steps = 12;
        for(let i=0;i<=steps;i++){
          const t = i/steps; const y = -h/2 + h*t; const belly = 1 - Math.pow(2*t-1, 2);
          let radius = r * (0.82 + 0.18*belly);
          if(i===0 || i===steps){ radius *= (1 - endplateConcavity); }
          pts.push(new THREE.Vector2(radius, y));
        }
        return pts;
      }
      
      // createVertebraDetailed (MODIFICADO: Simplificado)
      function createVertebraDetailed(vertebraType, scale, i){
        const g = new THREE.Group();
        // Cuerpo vertebral
        const profile = latheBodyProfile(scale, vertebraType==='lumbar'?0.08:vertebraType==='thoracic'?0.06:0.05);
        let bodyGeo = new THREE.LatheGeometry(profile, 28);
        if(subd && subd.modify) bodyGeo = subd.modify(bodyGeo);
        const body = new THREE.Mesh(bodyGeo, vertebraMaterialBase.clone());
        body.castShadow = body.receiveShadow = true;
        // Asignación de nombre anatómico
        let anatomicalName = 'Vertebra';
        if (vertebraType === 'cervical') {
            anatomicalName = `C${i + 1}`; // C1-C7
        } else if (vertebraType === 'thoracic') {
            anatomicalName = `T${i - NUM_CERVICAL + 1}`; // T1-T12
        } else if (vertebraType === 'lumbar') {
            anatomicalName = `L${i - (NUM_CERVICAL + NUM_THORACIC) + 1}`; // L1-L5
        }
        body.name = `VertebraBody_${anatomicalName}`;
        body.userData.index = i;
        body.userData.type = vertebraType;
        body.userData.anatomicalName = anatomicalName;
        body.userData.screws = null;
        g.add(body);
        
        // --- INICIO DE CAMBIO ---
        // Se elimina la adición de pedículos, láminas, apófisis espinosa y transversa.
        // El cuerpo vertebral por sí solo ya es una buena representación simple.
        // --- FIN DE CAMBIO ---

        // Guardar datos para discos (sin cambios)
        const bbox = new THREE.Box3().setFromObject(body);
        const vHeight = bbox.getSize(new THREE.Vector3()).y;
        g.userData.height = vHeight;
        g.userData.radiusTop = profile[profile.length-1].x;
        g.userData.radiusBottom = profile[0].x;
        return g;
      }

      // --- NUEVO: Procesamiento de AMBAS curvas 2D ---
      const MAX_CORONAL_DEVIATION = 3.5; // (AP) Desviación X
      const MAX_SAGITTAL_DEVIATION = 3.0; // (LAT) Desviación Z
      
      let patientCurveMap_AP = processPointsToCurveMap(points2D_AP, MAX_CORONAL_DEVIATION);
      let patientCurveMap_LAT = processPointsToCurveMap(points2D_LAT, MAX_SAGITTAL_DEVIATION);
      // --- FIN DE NUEVO CÓDIGO ---

      // Construcción con curvaturas...
      for(let i=0;i<NUM_MOBILE;i++){
        let vertebraType, scaleFactor;
        // Lógica de scaleFactor (sin cambios)
        if(i<NUM_CERVICAL){
          vertebraType='cervical';
          scaleFactor = THREE.MathUtils.lerp(0.9,1.05, i/(NUM_CERVICAL-1));
        } else if(i<NUM_CERVICAL+NUM_THORACIC){
          vertebraType='thoracic';
          scaleFactor = THREE.MathUtils.lerp(1.05,1.35,(i-NUM_CERVICAL)/(NUM_THORACIC-1));
        } else {
          vertebraType='lumbar';
          scaleFactor = THREE.MathUtils.lerp(1.4,1.7,(i-(NUM_CERVICAL+NUM_THORACIC))/(NUM_LUMBAR-1));
        }

        const vertebra = createVertebraDetailed(vertebraType, scaleFactor, i);

        // Curvaturas: coronal (escoliosis), sagital (lordosis/kyphosis), axial (rotación)
        const t = i/(NUM_MOBILE-1); // t de 0 a 1
        
        // --- MODIFICADO: Definición de xCurv (Coronal/AP) ---
        let xCurv;
        if (patientCurveMap_AP) {
          xCurv = patientCurveMap_AP(t); 
        } else {
          // Fallback coronal
          xCurv = Math.sin(t*Math.PI*2)*2.0; 
        }

        // --- MODIFICADO: Definición de zOff (Sagital/LAT) ---
        let zOff;
        if (patientCurveMap_LAT) {
          zOff = patientCurveMap_LAT(t);
        } else {
          // Fallback sagital (lógica procedural anterior)
          if(vertebraType==='cervical'){ zOff = Math.sin(t*Math.PI*2.5)*-0.8*scaleFactor; }
          else if(vertebraType==='thoracic'){ zOff = Math.sin(t*Math.PI*2.0)*1.3*scaleFactor; }
          else { zOff = Math.sin(t*Math.PI*1.6)*-1.1*scaleFactor; }
        }
        
        // Rotaciones (aún procedurales, podrían mejorarse en el futuro)
        let rotX=0, rotY=0;
        if(vertebraType==='cervical'){ rotX = Math.sin(t*Math.PI)*-0.12; rotY = Math.sin(t*Math.PI)*0.18; }
        else if(vertebraType==='thoracic'){ rotX = Math.sin(t*Math.PI)*0.22; rotY = Math.sin(t*Math.PI)*0.28; }
        else { rotX = Math.sin(t*Math.PI)*-0.2; rotY = Math.sin(t*Math.PI)*0.22; }

        // Wedge (sin cambios)
        if(vertebraType==='thoracic'){
          const wedge = THREE.MathUtils.lerp(-0.06, 0.06, Math.sin(t*Math.PI*2)*0.5+0.5);
          vertebra.rotation.z += wedge;
        }

        // Posicionar
        vertebra.position.set(xCurv, currentY, zOff);
        vertebra.rotation.x += rotX; vertebra.rotation.y += rotY;

        group.add(vertebra);

        // Discos intervertebrales (actualizados)
        if(i<NUM_MOBILE-1){
          // ... (Lógica de tamaño de disco sin cambios) ...
          const nextScale = (i+1<NUM_CERVICAL)?THREE.MathUtils.lerp(0.9,1.05,(i+1)/(NUM_CERVICAL-1))
                           : (i+1<NUM_CERVICAL+NUM_THORACIC)?THREE.MathUtils.lerp(1.05,1.35,(i+1-NUM_CERVICAL)/(NUM_THORACIC-1))
                           : THREE.MathUtils.lerp(1.4,1.7,(i+1-(NUM_CERVICAL+NUM_THORACIC))/(NUM_LUMBAR-1));
          const discH = baseDiscHeight*THREE.MathUtils.lerp(0.9,1.2, nextScale/1.7);
          const discR = Math.min(vertebra.userData.radiusTop, 1.2*nextScale)*0.95;
          const discGeo = new THREE.CylinderGeometry(discR, discR*0.98, discH, 24);
          const disc = new THREE.Mesh(discGeo, discMaterialBase.clone());
          const nextY = currentY + vertebra.userData.height + discH/2;
          
          // --- MODIFICADO: El disco también sigue AMBAS curvas ---
          const t_disc = (t + ( (i+1)/(NUM_MOBILE-1) )) / 2; // t en el punto medio del disco
          let discX, discZ;
          
          if (patientCurveMap_AP) {
            discX = patientCurveMap_AP(t_disc);
          } else {
            discX = Math.sin( t_disc * Math.PI * 2 ) * 2.0; // Fallback AP
          }
          
          if (patientCurveMap_LAT) {
            discZ = patientCurveMap_LAT(t_disc);
          } else {
            // Fallback LAT (simplificado)
            discZ = zOff; 
          }
          
          disc.position.set(discX, nextY, discZ);
          disc.rotation.x = vertebra.rotation.x; disc.rotation.y = vertebra.rotation.y;
          group.add(disc);
          currentY = nextY + discH/2; // avanzar pila
        } else {
          currentY += vertebra.userData.height;
        }
      }

      // Sacro + coxis (simplificado también)
      // Se crea un "sacro" más simple, similar a una vértebra grande.
      const sacrumScale = 1.9;
      const sacrumProfile = latheBodyProfile(sacrumScale, 0.1); // Usar profile similar a vértebra
      let sacrumGeo = new THREE.LatheGeometry(sacrumProfile, 28);
      if(subd && subd.modify) sacrumGeo = subd.modify(sacrumGeo);
      const sacrum = new THREE.Mesh(sacrumGeo, vertebraMaterialBase.clone());
      sacrum.position.set(0, currentY + sacrumScale * 1.2, 1.2); 
      sacrum.rotation.x = 0.45; 
      sacrum.rotation.y = 0.2; // Ligera rotación para simular la forma
      group.add(sacrum);
      currentY += sacrumScale * 2.4; // Ajustar avance para el sacro simplificado

      // El cóccix puede ser un poco más pequeño
      const coccyx = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 12), vertebraMaterialBase.clone());
      coccyx.position.set(0, currentY - 1.0, 0.9); 
      coccyx.rotation.x = 0.9; 
      group.add(coccyx);

      // Elevar y orientar conjunto
      group.rotation.x = Math.PI; group.position.y = (currentY/2) + 10;
      return group;
    }

    // ---------- Interacción (raycast) ----------
    function onCanvasMouseDown(event){
      // ... (sin cambios) ...
      if(toolMode==='rod') return; 
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left)/rect.width)*2 - 1;
      mouse.y = -((event.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const bodies = [];
      spineGroup?.traverse(obj=>{ if(obj.isMesh && obj.name.startsWith('VertebraBody_')) bodies.push(obj); });
      const hit = raycaster.intersectObjects(bodies, false);
      if(!hit.length) {
        if (toolMode === 'cobb') {
            showToast('Clic fallido. Apunte a una vértebra.');
        }
        return;
      }
      const selectedObject = hit[0].object;
      const clickPoint = hit[0].point; 
      if(toolMode==='cobb') {
        handleCobbPointClick({ 
          point: clickPoint, 
          name: selectedObject.userData.anatomicalName 
        });
      } else if (toolMode === 'screws') {
        handleScrewSelection(selectedObject);
      }
    }

    // ---------- Herramientas ----------
    function resetToolMode(keepCobbPanel=false){ 
      // ... (sin cambios) ...
      const prev = toolMode; toolMode = null;
      cobbButton.classList.remove('tool-active');
      screwsButton.classList.remove('tool-active');
      rodButton.classList.remove('tool-active');
      screwInstructionPanel.classList.add('hidden');
      if(!keepCobbPanel || prev !== 'cobb') cobbResultsPanel.classList.add('hidden');
      cobbClickPoints = []; 
      currentCobbAngle = 0.0;
      COBB_POINTS_GROUP.clear();
      cobbActions.classList.add('hidden');
      cobbInstruction.textContent = 'Seleccione 3 puntos en la placa superior de la vértebra superior.';
      cobbSelectedPoints.innerHTML = 'Puntos placa superior: 0/3<br/>Puntos placa inferior: 0/3';
      cobbResult.textContent = '0.0°';
      if(prev==='rod') RODS_GROUP.clear();
    }

    // Listeners de botones de herramientas (sin cambios)
    cobbButton.addEventListener('click', ()=>{
      if(toolMode==='cobb') { resetToolMode(); return; }
      resetToolMode(true); toolMode='cobb'; cobbButton.classList.add('tool-active');
      cobbResultsPanel.classList.remove('hidden');
      if(savedCobbMeasurements.length>0) cobbHistoryPanel.classList.remove('hidden'); else cobbHistoryPanel.classList.add('hidden');
      showToast('Modo Cobb activo');
    });
    screwsButton.addEventListener('click', ()=>{
      if(toolMode==='screws'){ resetToolMode(); return; }
      resetToolMode(); 
      toolMode='screws'; 
      screwsButton.classList.add('tool-active');
      screwInstructionPanel.classList.remove('hidden');
      showToast('Modo Tornillos activo: Clic en vértebras');
    });
    rodButton.addEventListener('click', ()=>{
      if(toolMode==='rod'){ resetToolMode(); return; }
      resetToolMode(); 
      toolMode='rod'; 
      rodButton.classList.add('tool-active');
      simulateCorrectionRod(); 
    });
    
    // Lógica de Cobb (save, clear, history, etc.) (sin cambios)
    clearCobbButton.addEventListener('click', ()=> resetToolMode(true));
    saveCobbButton.addEventListener('click', ()=>{
      if(cobbClickPoints.length === 6 && currentCobbAngle > 0){
        const v1Name = cobbClickPoints[0].name;
        const v2Name = cobbClickPoints[3].name;
        const entry = { id: savedCobbMeasurements.length+1, v1:v1Name, v2:v2Name, angle: currentCobbAngle.toFixed(1) };
        savedCobbMeasurements.push(entry);
        updateCobbHistoryUI();
        resetToolMode(true);
        cobbInstruction.textContent = '¡Medición guardada! Seleccione las vértebras para la siguiente medición.';
      }
    });
    function updateCobbHistoryUI(){
      cobbMeasurementsList.innerHTML = '';
      if(savedCobbMeasurements.length===0){
        cobbHistoryPanel.classList.add('hidden');
        cobbMeasurementsList.innerHTML = '<li class="text-gray-400 italic">No hay mediciones guardadas.</li>';
        return;
      }
      cobbHistoryPanel.classList.remove('hidden');
      for(const m of savedCobbMeasurements){
        const li = document.createElement('li');
        li.className = 'flex justify-between items-center p-2 bg-gray-700 rounded-md';
        li.innerHTML = `<span class="font-medium text-yellow-200">Curva ${m.id} (${m.v1}-${m.v2}):</span><span class="font-extrabold text-green-400 text-xl">${m.angle}°</span>`;
        cobbMeasurementsList.appendChild(li);
      }
    }
    const cobbPointGeometry = new THREE.SphereGeometry(0.15, 16, 16);
    const cobbPointMaterialTop = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
    const cobbPointMaterialBottom = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.8 });
    function handleCobbPointClick(clickData) {
        if (cobbClickPoints.length >= 6) {
            showToast('Ya se han seleccionado 6 puntos. Limpie para una nueva medición.');
            return;
        }
        cobbClickPoints.push(clickData);
        const isTopPlate = cobbClickPoints.length <= 3;
        const material = isTopPlate ? cobbPointMaterialTop : cobbPointMaterialBottom;
        const pointMarker = new THREE.Mesh(cobbPointGeometry, material);
        pointMarker.position.copy(clickData.point);
        COBB_POINTS_GROUP.add(pointMarker);
        updateCobbPanelUI();
        if (cobbClickPoints.length === 3) {
            calculateCobbAngleFromPoints();
        } else if (cobbClickPoints.length === 6) {
            calculateCobbAngleFromPoints();
            cobbActions.classList.remove('hidden');
        }
    }
    function updateCobbPanelUI() {
        const topPoints = Math.min(cobbClickPoints.length, 3);
        const bottomPoints = Math.max(0, cobbClickPoints.length - 3);
        cobbSelectedPoints.innerHTML = `Puntos placa superior: ${topPoints}/3<br/>Puntos placa inferior: ${bottomPoints}/3`;
        if (cobbClickPoints.length < 3) {
            cobbInstruction.textContent = `Seleccione el punto ${topPoints + 1}/3 en la placa superior.`;
        } else if (cobbClickPoints.length === 3) {
            cobbInstruction.textContent = 'Seleccione el punto 1/3 en la placa inferior.';
        } else if (cobbClickPoints.length < 6) {
            cobbInstruction.textContent = `Seleccione el punto ${bottomPoints + 1}/3 en la placa inferior.`;
        } else {
            cobbInstruction.textContent = '¡Medición completa! Guarde o limpie para continuar.';
        }
    }
    function acuteAngleRad(r){
      let d = Math.abs(r); if(d>Math.PI) d = 2*Math.PI - d; if(d>Math.PI/2) d = Math.PI - d; return d;
    }
    function calculateCobbAngleFromPoints() {
        if (cobbClickPoints.length < 3) return;
        const lineMaterialTop = new THREE.LineBasicMaterial({ color: 0x00ff00 }); // Verde
        const lineMaterialBottom = new THREE.LineBasicMaterial({ color: 0xffa500 }); // Naranja
        function drawPlaneLine(plane, center, material) {
            const len = 22;
            let lineDir = new THREE.Vector3(1, 0, 0);
            let projectedCenter = plane.projectPoint(new THREE.Vector3(0,0,0), new THREE.Vector3());
            plane.projectPoint(lineDir, lineDir);
            lineDir.sub(projectedCenter); 
            lineDir.normalize();
            if (lineDir.lengthSq() < 0.5) { 
                lineDir.set(0, 1, 0);
                plane.projectPoint(lineDir, lineDir);
                lineDir.sub(projectedCenter);
                lineDir.normalize();
            }
            const p1 = center.clone().addScaledVector(lineDir, len / 2);
            const p2 = center.clone().addScaledVector(lineDir, -len / 2);
            const geom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
            const line = new THREE.Line(geom, material);
            COBB_POINTS_GROUP.add(line);
        }
        const p1 = cobbClickPoints[0].point;
        const p2 = cobbClickPoints[1].point;
        const p3 = cobbClickPoints[2].point;
        const planeTop = new THREE.Plane().setFromCoplanarPoints(p1, p2, p3);
        const centerTop = p1.clone().add(p2).add(p3).divideScalar(3);
        COBB_POINTS_GROUP.children = COBB_POINTS_GROUP.children.filter(c => !c.isLine);
        drawPlaneLine(planeTop, centerTop, lineMaterialTop);
        if (cobbClickPoints.length < 6) {
            cobbResult.textContent = '...';
            return;
        }
        const p4 = cobbClickPoints[3].point;
        const p5 = cobbClickPoints[4].point;
        const p6 = cobbClickPoints[5].point;
        const planeBottom = new THREE.Plane().setFromCoplanarPoints(p4, p5, p6);
        const centerBottom = p4.clone().add(p5).add(p6).divideScalar(3);
        drawPlaneLine(planeBottom, centerBottom, lineMaterialBottom);
        const angleRad = planeTop.normal.angleTo(planeBottom.normal);
        currentCobbAngle = THREE.MathUtils.radToDeg(acuteAngleRad(angleRad));
        cobbResult.textContent = `${currentCobbAngle.toFixed(1)}°`;
    }
    
    // Lógica de Tornillos (handleScrewSelection, place, remove) (sin cambios)
    function handleScrewSelection(bodyMesh) {
      if (bodyMesh.userData.screws && bodyMesh.userData.screws.length > 0) {
        removePedicleScrewsAt(bodyMesh);
        showToast(`Tornillos quitados de ${bodyMesh.userData.anatomicalName}`);
      } else {
        placePedicleScrewsAt(bodyMesh);
        showToast(`Tornillos colocados en ${bodyMesh.userData.anatomicalName}`);
      }
    }
    function placePedicleScrewsAt(bodyMesh) {
      const parent = bodyMesh.parent; 
      if (!parent || !bodyMesh.geometry.parameters) {
        console.warn('No se puede colocar tornillo: falta el grupo padre o los parámetros de geometría.');
        return;
      }
      // Para las vértebras simplificadas, ajustamos la posición del tornillo.
      // Los tornillos ahora se colocarán directamente en el "cuerpo" simple de la vértebra.
      const center = new THREE.Vector3(); 
      bodyMesh.getWorldPosition(center);
      
      // Ajustar las posiciones de los tornillos para el modelo simplificado
      // Aquí puedes experimentar con los valores para que se vean bien
      const lateralOffset = bodyMesh.userData.radiusTop * 0.7; // Más hacia el centro
      const posteriorOffset = bodyMesh.userData.height * 0.1; // Ligeramente hacia atrás del centro

      const Llocal = new THREE.Vector3(-lateralOffset, 0, posteriorOffset); 
      const Rlocal = new THREE.Vector3(lateralOffset, 0, posteriorOffset);

      const L = Llocal.clone().applyMatrix4(parent.matrixWorld);
      const R = Rlocal.clone().applyMatrix4(parent.matrixWorld);
      
      const screwL = new THREE.Mesh(screwGeometry, screwMaterial); 
      screwL.position.copy(L);
      // Orientación del tornillo: apuntar hacia el centro de la vértebra
      screwL.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), new THREE.Vector3().subVectors(center, L).normalize()));
      
      const screwR = new THREE.Mesh(screwGeometry, screwMaterial); 
      screwR.position.copy(R);
      screwR.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), new THREE.Vector3().subVectors(center, R).normalize()));
      
      SCREWS_GROUP.add(screwL, screwR);
      bodyMesh.userData.screws = [screwL, screwR];
    }
    function removePedicleScrewsAt(bodyMesh) {
      const screws = bodyMesh.userData.screws;
      if (screws && screws.length > 0) {
        screws.forEach(screw => {
          SCREWS_GROUP.remove(screw);
        });
      }
      bodyMesh.userData.screws = null;
    }

    // Simulación de Barra (simulateCorrectionRod) (sin cambios)
    function simulateCorrectionRod(){
      RODS_GROUP.clear();
      if(SCREWS_GROUP.children.length < 4) {
         showToast('Error: Debe colocar al menos 4 tornillos (en 2 vértebras) para simular una barra.');
         resetToolMode();
         return;
      }
      const leftScrews = SCREWS_GROUP.children.filter((_,idx)=> idx%2===0);
      const worldPos = leftScrews.map(m=>{ 
        const v=new THREE.Vector3(); 
        m.getWorldPosition(v); 
        return {m, y:v.y, v}; 
      }).sort((a,b)=>b.y-a.y);
      const points = worldPos.map(o=>o.v);
      const curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.1);
      const tube = new THREE.TubeGeometry(curve, Math.max(20, points.length*3), 0.15, 8, false);
      const rodMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.2 });
      const rod = new THREE.Mesh(tube, rodMat);
      RODS_GROUP.add(rod);
      if(!scene.children.includes(RODS_GROUP)) scene.add(RODS_GROUP);
      showToast('Barra correctora simulada');
    }

    // ---------- Exportación ----------
    exportButton.addEventListener('click', ()=>{
      const payload = buildExportPayload();
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type:'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `plan_gemelo_digital_AP-LAT_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      canvas.toBlob((png)=>{
        if(!png) return; const a2 = document.createElement('a'); a2.href = URL.createObjectURL(png); a2.download = 'vista_3D.png'; a2.click(); URL.revokeObjectURL(a2.href);
      }, 'image/png');
      showToast('Plan exportado (JSON + PNG)');
    });

    // MODIFICADO: Incluir ambos arrays de puntos
    function buildExportPayload(){
      const screws = SCREWS_GROUP.children.map((m,idx)=>{
        const p = new THREE.Vector3(); m.getWorldPosition(p);
        const q = new THREE.Quaternion(); m.getWorldQuaternion(q);
        return { id: idx+1, position:{x:p.x,y:p.y,z:p.z}, quaternion:{x:q.x,y:q.y,z:q.z,w:q.w} };
      });
      const cobb = savedCobbMeasurements.slice();
      return {
        app: 'Gemelo Digital (demo) - Escoliosis (AP+LAT)',
        timestamp: new Date().toISOString(),
        patientImageAP: fileNameElAP.textContent || null,
        patientImageLAT: fileNameElLAT.textContent || null,
        patientCurvePoints2D_AP: patientSpinePoints2D_AP, // (SVG coords)
        patientCurvePoints2D_LAT: patientSpinePoints2D_LAT, // (SVG coords)
        cobbMeasurements: cobb,
        screwCount: screws.length,
        screws,
        notes: 'Datos generados con fines demostrativos. No usar para diagnóstico.'
      };
    }

    // ---------- Atajos de teclado ----------
    document.addEventListener('keydown', (e)=>{
      // ... (sin cambios) ...
      if(e.target && ['INPUT','TEXTAREA'].includes(e.target.tagName)) return;
      const k = e.key.toLowerCase();
      if(k==='c' && !cobbButton.disabled) cobbButton.click();
      if(k==='s' && !screwsButton.disabled) screwsButton.click();
      if(k==='r') { 
        if (spineGroup) {
          spineGroup.traverse(obj => { 
            if (obj.isMesh && obj.name.startsWith('VertebraBody_')) { 
              obj.userData.screws = null; 
            } 
          });
        }
        SCREWS_GROUP.clear();
        resetToolMode(); 
        showToast('Herramientas reiniciadas'); 
      }
      if(k==='e' && !exportButton.disabled) exportButton.click();
    });

    // ========== TESTS BÁSICOS (auto) ==========
    function runSelfTests(){
      // ... (sin cambios) ...
      try{
        console.group('%cSelfTests Gemelo Digital','color:#a7f3d0');
        const d1 = acuteAngleRad(THREE.MathUtils.degToRad(170));
        console.assert(Math.abs(THREE.MathUtils.radToDeg(d1)-10)<1e-6, 'acuteAngleRad falla para 170°');
        const p1 = new THREE.Vector3(0, 0, 0); const p2 = new THREE.Vector3(1, 0, 0); const p3 = new THREE.Vector3(0, 1, 0);
        const planeXY = new THREE.Plane().setFromCoplanarPoints(p1, p2, p3);
        console.assert(Math.abs(planeXY.normal.z) > 0.99, 'Cálculo de plano falla para plano XY');
        const p4 = new THREE.Vector3(0, 0, 0); const p5 = new THREE.Vector3(1, 1, 0); const p6 = new THREE.Vector3(0, 1, 0);
        const planeXY_2 = new THREE.Plane().setFromCoplanarPoints(p4, p5, p6);
        console.assert(Math.abs(planeXY_2.normal.z) > 0.99, 'Cálculo de plano falla para plano XY (2)');
        console.groupEnd();
      }catch(err){
        console.error('SelfTests error:', err);
        showToast(' Fallaron tests internos. Ver consola.');
      }
    }

    // Inicializar
    document.addEventListener('DOMContentLoaded', ()=>{ updateCobbHistoryUI(); runSelfTests(); });
  </script>
</body>
</html>

